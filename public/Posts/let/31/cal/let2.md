컴퓨터구조 3주차 수업
*^*MET*^*
# 명령어집합 (ISA)
- 컴퓨터가 실행하는 어셈블리어 명령어들의 집합.
- **특정 CPU를 위해 정의된 명령어의 모음**

# 실행파일의 생성과정
- C lang > Compiler > .obj > linker > .exe
- 어셈블러
> C를 번역한다.
- 링커
  > 종속성을 관리
- 로더
  > 명령어를 CPU에 적재해준다.

# ISA 설계
## 설계 논점
- 연산종류
- 데이터 형식
- 명령어 형식
  > 연산부호. 명령어의 구성부분 
- 피연산자를 위한 주소지정방식
  > 데이터의 위치를 명시하는 방법.

# 명령어 특성
## 명령어의 정의
- 컴퓨터가 수행가능한 기계어 동작을 정의한것. 
- 어셈블리어와는 1:1 mapping.
## 명령어의 구성
- opcode (연산부호)
- 피 연산자필드
- ~~모드비트~~
> 순차성에 의해서 필요가 없어짐.
- ~~다음명령어 주소필드~~ 
> 순차성에 의해서 필요가 없어짐.
```
[ADD][R1 R2 R3] -> R2 + R3 = R1에 넣기 ... 뭐 그런
```
## 피 연산자의 수
- 무항 연산자
  > Halt, -> 전체정지
  > nop->명령어 정지    
  > 프로그램 정지   
- 단항 연산자
  > not n1
- 이항 연산자
  > add r1,r2   
  > //r1+r2->r1
- 삼항 연산자
  > add r1,r2,r3  
  > //r2+r3 -> r1
- 다항 연산자
  > madd.....
> 사실 명령어 정의에 따라서 다 달라진다!

## 피연산자의 수를 줄이는 방법
- 일반적인 함수유형
$$z=f(x,y)$$
1. z = f(x,z)
2. Acc = f(Acc , x)(Acc : 특수목적 레지스터.)
3. 스택사용 (사실cost가 큰데....)
4. 메모리대신 레지스터 주소사용
- 명령어의 인수를 줄이는 이유 : 
  >저장소간 로딩문제에 의한 병목현상을 해결한다.   
  >(폰 노이만 방식 컴퓨터의 문제)

# 폰 노이만 모델
- PC
> Program Counter : 다음 실행할 **명령어의 주소**를 보관
- IR


## 명령어 실행순서
- 적재과정 (LOAD LDA)
> 메모리 to CPU

- 저장과정(STORE STA)
> CPU to 메모리


# CPU기본 구성과 명령어 실행순서
- 명령어 사이클
> 인출 Fetch -> 실행 Execution    
> IF = MBR -> IR  
> IR에 PC가 가르키는 명령어 적재후, PC가 다음 명령어 가르키도록 갱신.   
- 인출보다 실행이 더 많아서 실행사이클이 더 많다.


# 가상 컴퓨터
- 누산기 : 묵시적인 레지스터... 
- 명령어의 종류

|명령어|연산부호(16)|의미|
|-----|----|----|
|LDA|1|메모리의 내용을 누산기에 저장|
|STA|2|누산기의 내용을 메모리에 저장|
|ADD|3|누산기 + 메모리|
|SUB|4|누산기 - 메모리|
|JMP|5|분기|
... 라면....
- 이 컴퓨터는 폰 노이만 구조인가?
> 그렇다. 메모리와 실행장치가 분리되어있기 떄문.
- 명령이 끝난 후 PC가 증가되는 이유?
> 다음 명령어를 실행시키기 위하여. 더하지 않는다면, 절차성 보장이 불가하다. 

# 알아둬야 할 개념
- PC
> 프로그램 카운터
- IR
> 인출...fetch

# 좋은 병령어 집합구조.
- 일관성
  > 일부 구조만 알아도 구조의 예측가능성 
- 직교성
  > 구성요소가 연산부호와 독립적 결정
- 적절성
  > 본질적이어야함. 관계가 있어야함.
- 일반성
  > 하나의 기능을 다양한 목적으로.
- 완전성
- 확장성

# 연산의 종류
- 전송연산
  > 레지스터-메모리간 데이터 교환
- 처리연산
  > 산술 논리장치 사용
- 제어연산
  > 실행순서
- 입출력연산
  > I/O

# 분기연산
> 비순차적 실행을 구현시킴
## 구현방식
> 명령어가 다음 명령어를 가르킨다.
## 문기 명령어의 종류
### 무조건 분기

### 조건분기
#### 조건분기의 두가지 과정
- 검사조건 생성
- 조건 판단및 위치선택
##### 조건 생성
- 묵시적 조건 생성 ...> 플래그 레지스터
- 명시적 조건 생성 ...> CMP,TEST(TST) 명령어 활용
- 플래그 레지스터의 종류
> 올림수(C), 오버플로우(V), 부호(S), 0(Z)   
> C.f (carry flag = 1(올림수 발생)) ...

#### 조건분기의 3가지 유현
- 묵시적 조건생성 + 분기 명령
- 명시적 조건생성 + 분기 명령
- 비교분기 융합명령

## 폰 노이만 병목
- CPU와 메모리사이의 데이터 교환 량
- 

## 명령어의 구성
- 명령어   (2)
- 피연산자 (1) 
> order가 9개==> 9*3 = 27 byte traffic같은 느낌 

## 데이터 트래픽
- 연산 데이터
> 4 * 9 = 36

# 스택
- 자료구조의 일종.
- 선입후출. JS, stack overflow.... 
- push,pop

# 스택컴퓨터
- 스택만 있는 컴퓨터, 누산기가 없다.
- 스택위에만 두고 계산한다. 누산기에 비하여 트래픽이 줄어들 수 있다.

# 적재저장?
- 스택과 누산기는 적재저장이 아니다.
- 적재저장은, 메모리 접근을 해야한다. load, store를 해야함.
- 그런데 누산기는, 레지스터를 갈군다는 표현이 적합
- 스택은 아예 없다.

# GPRC
- 트래픽을 감소시킴. (예제가 복잡해질수록 더 크게 감소한다!)


# P.S.
- 닉네임... 어셈블리어에 있다...
- BRZ,SUB,BGT...