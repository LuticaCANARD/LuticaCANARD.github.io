컴퓨터구조 3주차 수업
*^*MET*^*
# 명령어집합 (ISA)
- 컴퓨터가 실행하는 어셈블리어 명령어들의 집합.
- **특정 CPU를 위해 정의된 명령어의 모음**

# 실행파일의 생성과정
- C lang > Compiler > .obj > linker > .exe
- 어셈블러
> C를 번역한다.
- 링커
  > 종속성을 관리
- 로더
  > 명령어를 CPU에 적재해준다.

# ISA 설계
## 설계 논점
- 연산종류
- 데이터 형식
- 명령어 형식
  > 연산부호. 명령어의 구성부분 
- 피연산자를 위한 주소지정방식
  > 데이터의 위치를 명시하는 방법.

# 명령어 특성
## 명령어의 정의
- 컴퓨터가 수행가능한 기계어 동작을 정의한것. 
- 어셈블리어와는 1:1 mapping.
## 명령어의 구성
- opcode (연산부호)
- 피 연산자필드
- ~~모드비트~~
> 순차성에 의해서 필요가 없어짐.
- ~~다음명령어 주소필드~~ 
> 순차성에 의해서 필요가 없어짐.
```
[ADD][R1 R2 R3] -> R2 + R3 = R1에 넣기 ... 뭐 그런
```
## 피 연산자의 수
- 무항 연산자
  > Halt, -> 전체정지
  > nop->명령어 정지    
  > 프로그램 정지   
- 단항 연산자
  > not n1
- 이항 연산자
  > add r1,r2   
  > //r1+r2->r1
- 삼항 연산자
  > add r1,r2,r3  
  > //r2+r3 -> r1
- 다항 연산자
  > madd.....
> 사실 명령어 정의에 따라서 다 달라진다!

## 피연산자의 수를 줄이는 방법
- 일반적인 함수유형
$$z=f(x,y)$$
1. z = f(x,z)
2. Acc = f(Acc , x)(Acc : 특수목적 레지스터.)
3. 스택사용 (사실cost가 큰데....)
4. 메모리대신 레지스터 주소사용
- 명령어의 인수를 줄이는 이유 : 
  >저장소간 로딩문제에 의한 병목현상을 해결한다.   
  >(폰 노이만 방식 컴퓨터의 문제)

# 폰 노이만 모델
- PC
> Program Counter : 다음 실행할 **명령어의 주소**를 보관
- IR


## 명령어 실행순서
- 적재과정 (LOAD LDA)
> 메모리 to CPU

- 저장과정(STORE STA)
> CPU to 메모리


# CPU기본 구성과 명령어 실행순서
- 명령어 사이클
> 인출 Fetch -> 실행 Execution    
> IF = MBR -> IR  
> IR에 PC가 가르키는 명령어 적재후, PC가 다음 명령어 가르키도록 갱신.   
- 인출보다 실행이 더 많아서 실행사이클이 더 많다.
- 